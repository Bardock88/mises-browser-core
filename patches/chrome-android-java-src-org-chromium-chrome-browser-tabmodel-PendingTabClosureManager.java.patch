diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/PendingTabClosureManager.java b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/PendingTabClosureManager.java
index cc2f03a1deb01be726e9a8faa15c7fccd054b8f7..b0f2288b26d0e22de062f548a0f08ba486752b23 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/PendingTabClosureManager.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/PendingTabClosureManager.java
@@ -7,6 +7,7 @@ package org.chromium.chrome.browser.tabmodel;
 import androidx.annotation.NonNull;
 
 import org.chromium.chrome.browser.tab.Tab;
+import org.chromium.chrome.browser.tab.state.CriticalPersistedTabData;
 
 import java.util.ArrayList;
 import java.util.HashSet;
@@ -154,6 +155,32 @@ public class PendingTabClosureManager {
             return mRewoundTabs.indexOf(tab);
         }
 
+        private Tab findTabInAllTabModels(int tabId) {
+            Tab tab = TabModelUtils.getTabById(mModelDelegate.getModel(isIncognito()), tabId);
+            if (tab != null) return tab;
+            return TabModelUtils.getTabById(mModelDelegate.getModel(!isIncognito()), tabId);
+        }
+
+	@Override
+    	public int getLastNonExtensionActiveIndex() {
+	//            Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 1");
+            if (mTabModel.getLastNonExtensionActiveIndex() != INVALID_TAB_INDEX) {
+//                Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 1a");
+                Tab parentTab = findTabInAllTabModels(CriticalPersistedTabData.from(TabModelUtils.getCurrentTab(this)).getParentId());
+//                Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 1b");
+                if (parentTab != null) {
+//                  Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 2a");
+                  return mRewoundTabs.indexOf(parentTab);
+                }
+//                Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 3");
+                return mRewoundTabs.indexOf(TabModelUtils.getCurrentTab(mTabModel));
+            }
+//            Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 4");
+            if (!mRewoundTabs.isEmpty()) return 0;
+//            Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 5");
+            return INVALID_TAB_INDEX;
+        }
+
         /**
          * Resets this list to match the original {@link TabList}.  Note that if the
          * {@link TabList} doesn't support pending closures this model will be empty.  This should
