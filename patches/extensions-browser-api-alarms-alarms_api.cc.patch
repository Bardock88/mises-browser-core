diff --git a/extensions/browser/api/alarms/alarms_api.cc b/extensions/browser/api/alarms/alarms_api.cc
index e7325c0c408e36ca9aeffcb1a78ad95f334d51d0..88c785e54e3ef4449363081cce44ce7981af3224 100644
--- a/extensions/browser/api/alarms/alarms_api.cc
+++ b/extensions/browser/api/alarms/alarms_api.cc
@@ -10,6 +10,7 @@
 
 #include "base/functional/bind.h"
 #include "base/strings/string_number_conversions.h"
+#include "base/strings/stringprintf.h"
 #include "base/time/clock.h"
 #include "base/time/default_clock.h"
 #include "base/values.h"
@@ -25,11 +26,13 @@ namespace alarms = api::alarms;
 
 namespace {
 
-const char kDefaultAlarmName[] = "";
-const char kBothRelativeAndAbsoluteTime[] =
+constexpr char kDefaultAlarmName[] = "";
+constexpr char kBothRelativeAndAbsoluteTime[] =
     "Cannot set both when and delayInMinutes.";
-const char kNoScheduledTime[] =
+constexpr char kNoScheduledTime[] =
     "Must set at least one of when, delayInMinutes, or periodInMinutes.";
+constexpr char kMaxAlarmsError[] =
+    "An extension cannot have more than %d active alarms.";
 
 bool ValidateAlarmCreateInfo(const std::string& alarm_name,
                              const alarms::AlarmCreateInfo& create_info,
@@ -95,6 +98,16 @@ ExtensionFunction::ResponseAction AlarmsCreateFunction::Run() {
   std::unique_ptr<alarms::Create::Params> params(
       alarms::Create::Params::Create(args()));
   EXTENSION_FUNCTION_VALIDATE(params.get());
+
+  AlarmManager* const alarm_manager = AlarmManager::Get(browser_context());
+  EXTENSION_FUNCTION_VALIDATE(alarm_manager);
+
+  if (alarm_manager->GetCountForExtension(extension_id()) >=
+      AlarmManager::kMaxAlarmsPerExtension) {
+    return RespondNow(Error(base::StringPrintf(
+        kMaxAlarmsError, AlarmManager::kMaxAlarmsPerExtension)));
+  }
+
   const std::string& alarm_name = params->name.value_or(kDefaultAlarmName);
   std::vector<std::string> warnings;
   std::string error;
@@ -102,9 +115,9 @@ ExtensionFunction::ResponseAction AlarmsCreateFunction::Run() {
                                &error, &warnings)) {
     return RespondNow(Error(std::move(error)));
   }
-  for (std::vector<std::string>::const_iterator it = warnings.begin();
-       it != warnings.end(); ++it)
-    WriteToConsole(blink::mojom::ConsoleMessageLevel::kWarning, *it);
+  for (const std::string& warning : warnings) {
+    WriteToConsole(blink::mojom::ConsoleMessageLevel::kWarning, warning);
+  }
 
   const int kSecondsPerMinute = 60;
   base::TimeDelta granularity =
@@ -114,9 +127,9 @@ ExtensionFunction::ResponseAction AlarmsCreateFunction::Run() {
       kSecondsPerMinute;
 
   Alarm alarm(alarm_name, params->alarm_info, granularity, clock_->Now());
-  AlarmManager::Get(browser_context())
-      ->AddAlarm(extension_id(), std::move(alarm),
-                 base::BindOnce(&AlarmsCreateFunction::Callback, this));
+  alarm_manager->AddAlarm(
+      extension_id(), std::move(alarm),
+      base::BindOnce(&AlarmsCreateFunction::Callback, this));
 
   // AddAlarm might have already responded.
   return did_respond() ? AlreadyResponded() : RespondLater();
