diff --git a/ios/chrome/browser/ui/content_suggestions/content_suggestions_view_controller.mm b/ios/chrome/browser/ui/content_suggestions/content_suggestions_view_controller.mm
index 28733e6db09b8957bce6582e3cae68b4ade44c26..dcc37c4d85b02bad3d92c241a8c6afd21ac58f23 100644
--- a/ios/chrome/browser/ui/content_suggestions/content_suggestions_view_controller.mm
+++ b/ios/chrome/browser/ui/content_suggestions/content_suggestions_view_controller.mm
@@ -41,6 +41,8 @@
 #import "ui/base/l10n/l10n_util.h"
 #import "url/gurl.h"
 
+#import "mises/ios/browser/ui/content_suggestions/cells/content_suggestions_mises_item.h"
+
 #if !defined(__has_feature) || !__has_feature(objc_arc)
 #error "This file requires ARC support."
 #endif
@@ -107,6 +109,13 @@ @interface ContentSuggestionsViewController () <
 // List of all of the Most Visited views.
 @property(nonatomic, strong)
     NSMutableArray<ContentSuggestionsMostVisitedTileView*>* mostVisitedViews;
+@property(nonatomic, strong)
+    NSMutableArray<UIStackView*>* mostVisitedHorizontalStackView;
+@property(nonatomic, strong)
+    NSMutableArray<UIStackView*>* misesFeatureHorizontalStackView;
+@property(nonatomic, strong)
+    ContentSuggestionsMisesCell* misesEnterWeb3Cell;
+
 // Module Container for the Shortcuts.
 @property(nonatomic, strong)
     ContentSuggestionsModuleContainer* shortcutsModuleContainer;
@@ -138,638 +147,735 @@ @interface ContentSuggestionsViewController () <
 @implementation ContentSuggestionsViewController
 
 - (instancetype)init {
-  return [super initWithNibName:nil bundle:nil];
+    return [super initWithNibName:nil bundle:nil];
 }
 
 - (void)viewDidLoad {
-  [super viewDidLoad];
-
-  self.dragDropHandler = [[URLDragDropHandler alloc] init];
-  self.dragDropHandler.dropDelegate = self;
-  [self.view addInteraction:[[UIDropInteraction alloc]
-                                initWithDelegate:self.dragDropHandler]];
-
-  if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-    self.view.backgroundColor = [UIColor clearColor];
-  } else {
-    self.view.backgroundColor = ntp_home::NTPBackgroundColor();
-  }
-  self.view.accessibilityIdentifier = kContentSuggestionsCollectionIdentifier;
-
-  self.verticalStackView = [[UIStackView alloc] init];
-  self.verticalStackView.translatesAutoresizingMaskIntoConstraints = NO;
-  if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-    self.verticalStackView.spacing = ModuleVerticalSpacing();
-  }
-  self.verticalStackView.axis = UILayoutConstraintAxisVertical;
-  // A centered alignment will ensure the views are centered.
-  self.verticalStackView.alignment = UIStackViewAlignmentCenter;
-  // A fill distribution allows for the custom spacing between elements and
-  // height/width configurations for each row.
-  self.verticalStackView.distribution = UIStackViewDistributionFill;
-  [self.view addSubview:self.verticalStackView];
-  if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-    // Add bottom spacing to last module by applying it after
-    // `_verticalStackView`. If ShouldMinimizeSpacingForModuleRefresh() is YES,
-    // then no space is added after the last module.
-    CGFloat bottomSpacing =
-        ShouldMinimizeSpacingForModuleRefresh() ? 0 : kModuleVerticalSpacing;
-    [NSLayoutConstraint activateConstraints:@[
-      [self.verticalStackView.leadingAnchor
-          constraintEqualToAnchor:self.view.leadingAnchor],
-      [self.verticalStackView.trailingAnchor
-          constraintEqualToAnchor:self.view.trailingAnchor],
-      [self.verticalStackView.topAnchor
-          constraintEqualToAnchor:self.view.topAnchor],
-      [self.verticalStackView.bottomAnchor
-          constraintEqualToAnchor:self.view.bottomAnchor
-                         constant:-bottomSpacing]
-    ]];
-  } else {
-    AddSameConstraints(self.view, self.verticalStackView);
-  }
-
-  CGFloat horizontalSpacing =
-      ContentSuggestionsTilesHorizontalSpacing(self.traitCollection);
-  if (self.returnToRecentTabTile) {
-    UIView* parentView = self.returnToRecentTabTile;
+    [super viewDidLoad];
+    
+    self.dragDropHandler = [[URLDragDropHandler alloc] init];
+    self.dragDropHandler.dropDelegate = self;
+    [self.view addInteraction:[[UIDropInteraction alloc]
+                               initWithDelegate:self.dragDropHandler]];
+    
     if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-      self.returnToRecentTabContainer = [[ContentSuggestionsModuleContainer
-          alloc]
-          initWithContentView:self.returnToRecentTabTile
-                   moduleType:ContentSuggestionsModuleTypeReturnToRecentTab];
-      parentView = self.returnToRecentTabContainer;
-      [self.verticalStackView
-          addArrangedSubview:self.returnToRecentTabContainer];
+        self.view.backgroundColor = [UIColor clearColor];
     } else {
-      [self addUIElement:self.returnToRecentTabTile
-          withCustomBottomSpacing:content_suggestions::
-                                      kReturnToRecentTabSectionBottomMargin];
+        self.view.backgroundColor = [UIColor clearColor];
+        //self.view.backgroundColor = ntp_home::NTPBackgroundColor();
     }
-    CGFloat cardWidth = content_suggestions::SearchFieldWidth(
-        self.view.bounds.size.width, self.traitCollection);
-    [NSLayoutConstraint activateConstraints:@[
-      [parentView.widthAnchor constraintEqualToConstant:cardWidth],
-      [parentView.heightAnchor
-          constraintEqualToConstant:ReturnToRecentTabHeight()]
-    ]];
-  }
-  if (IsContentSuggestionsUIModuleRefreshEnabled() ||
-      [self.mostVisitedViews count] > 0) {
-    self.mostVisitedStackView = [[UIStackView alloc] init];
-    self.mostVisitedStackView.axis = UILayoutConstraintAxisHorizontal;
-    self.mostVisitedStackView.distribution = UIStackViewDistributionFillEqually;
-    self.mostVisitedStackView.spacing = horizontalSpacing;
-
+    self.view.accessibilityIdentifier = kContentSuggestionsCollectionIdentifier;
+    
+    self.verticalStackView = [[UIStackView alloc] init];
+    self.verticalStackView.translatesAutoresizingMaskIntoConstraints = NO;
     if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-      self.mostVisitedStackView.backgroundColor =
-          ntp_home::NTPBackgroundColor();
-      self.mostVisitedStackView.alignment = UIStackViewAlignmentTop;
-      self.mostVisitedModuleContainer =
-          [[ContentSuggestionsModuleContainer alloc]
-              initWithContentView:self.mostVisitedStackView
-                       moduleType:ContentSuggestionsModuleTypeMostVisited];
-      if (!self.mostVisitedViews) {
-        self.mostVisitedViews = [NSMutableArray array];
-        self.mostVisitedModuleContainer.isPlaceholder = YES;
-        // Add placeholder tiles if Most Visited Tiles are not ready yet.
-        for (int i = 0; i < 4; i++) {
-          ContentSuggestionsMostVisitedTileView* view =
-              [[ContentSuggestionsMostVisitedTileView alloc]
-                  initWithConfiguration:nil];
-          [self.mostVisitedViews addObject:view];
-        }
-      }
-      [self.verticalStackView
-          addArrangedSubview:self.mostVisitedModuleContainer];
-      CGFloat width =
-          GetModuleWidthForHorizontalTraitCollection(self.traitCollection);
-      self.mostVisitedContainerWidthAnchor =
-          [self.mostVisitedModuleContainer.widthAnchor
-              constraintEqualToConstant:width];
-      [NSLayoutConstraint
-          activateConstraints:@[ self.mostVisitedContainerWidthAnchor ]];
-    } else {
-      self.mostVisitedStackView.alignment = UIStackViewAlignmentTop;
-      [self addUIElement:self.mostVisitedStackView
-          withCustomBottomSpacing:kMostVisitedBottomMargin];
-      CGFloat width =
-          MostVisitedTilesContentHorizontalSpace(self.traitCollection);
-      CGFloat height =
-          MostVisitedCellSize(self.traitCollection.preferredContentSizeCategory)
-              .height;
-      [NSLayoutConstraint activateConstraints:@[
-        [self.mostVisitedStackView.widthAnchor constraintEqualToConstant:width],
-        [self.mostVisitedStackView.heightAnchor
-            constraintGreaterThanOrEqualToConstant:height]
-      ]];
-    }
-    [self populateMostVisitedModule];
-  }
-  BOOL noTrendingQueriesToShow =
-      self.trendingQueriesReceived && [self.trendingQueryViews count] == 0;
-  if (IsTrendingQueriesModuleEnabled() && !noTrendingQueriesToShow) {
-    self.trendingQueriesContainingView = [[UIView alloc] init];
-    self.trendingQueriesModuleContainer =
-        [[ContentSuggestionsModuleContainer alloc]
-            initWithContentView:self.trendingQueriesContainingView
-                     moduleType:ContentSuggestionsModuleTypeTrendingQueries];
-    if (!self.trendingQueryViews) {
-      self.trendingQueriesModuleContainer.isPlaceholder = YES;
-      self.trendingQueryViews = [NSMutableArray array];
-      // Add placeholder tiles if Most Visited Tiles are not ready yet.
-      for (int i = 0; i < 4; i++) {
-        QuerySuggestionView* view =
-            [[QuerySuggestionView alloc] initWithConfiguration:nil];
-        view.translatesAutoresizingMaskIntoConstraints = NO;
-        [self.trendingQueryViews addObject:view];
-      }
+        self.verticalStackView.spacing = ModuleVerticalSpacing();
     }
-    [self.verticalStackView
-        addArrangedSubview:self.trendingQueriesModuleContainer];
-    self.trendingQueriesContainerWidthAnchor =
-        [self.trendingQueriesModuleContainer.widthAnchor
-            constraintEqualToConstant:
-                GetModuleWidthForHorizontalTraitCollection(
-                    self.traitCollection)];
-    [NSLayoutConstraint
-        activateConstraints:@[ self.trendingQueriesContainerWidthAnchor ]];
-    [self populateTrendingQueriesModule];
-  }
-  if (self.shortcutsViews) {
-    self.shortcutsStackView = [[UIStackView alloc] init];
-    self.shortcutsStackView.axis = UILayoutConstraintAxisHorizontal;
-    self.shortcutsStackView.distribution = UIStackViewDistributionFillEqually;
-    self.shortcutsStackView.spacing = horizontalSpacing;
+    self.verticalStackView.axis = UILayoutConstraintAxisVertical;
+    // A centered alignment will ensure the views are centered.
+    self.verticalStackView.alignment = UIStackViewAlignmentCenter;
+    // A fill distribution allows for the custom spacing between elements and
+    // height/width configurations for each row.
+    self.verticalStackView.distribution = UIStackViewDistributionFill;
+    [self.view addSubview:self.verticalStackView];
     if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-      self.shortcutsStackView.alignment = UIStackViewAlignmentTop;
-      self.shortcutsStackView.backgroundColor = ntp_home::NTPBackgroundColor();
+        // Add bottom spacing to last module by applying it after
+        // `_verticalStackView`. If ShouldMinimizeSpacingForModuleRefresh() is YES,
+        // then no space is added after the last module.
+        CGFloat bottomSpacing =
+        ShouldMinimizeSpacingForModuleRefresh() ? 0 : kModuleVerticalSpacing;
+        [NSLayoutConstraint activateConstraints:@[
+            [self.verticalStackView.leadingAnchor
+             constraintEqualToAnchor:self.view.leadingAnchor],
+            [self.verticalStackView.trailingAnchor
+             constraintEqualToAnchor:self.view.trailingAnchor],
+            [self.verticalStackView.topAnchor
+             constraintEqualToAnchor:self.view.topAnchor],
+            [self.verticalStackView.bottomAnchor
+             constraintEqualToAnchor:self.view.bottomAnchor
+             constant:-bottomSpacing]
+        ]];
     } else {
-      self.shortcutsStackView.alignment = UIStackViewAlignmentTop;
+        AddSameConstraints(self.view, self.verticalStackView);
     }
-    NSUInteger index = 0;
-    for (ContentSuggestionsShortcutTileView* view in self.shortcutsViews) {
-      view.accessibilityIdentifier = [NSString
-          stringWithFormat:
-              @"%@%li",
-              kContentSuggestionsShortcutsAccessibilityIdentifierPrefix, index];
-      UITapGestureRecognizer* tapRecognizer = [[UITapGestureRecognizer alloc]
-          initWithTarget:self
-                  action:@selector(contentSuggestionsElementTapped:)];
-      [view addGestureRecognizer:tapRecognizer];
-      [self.mostVisitedTapRecognizers addObject:tapRecognizer];
-      [self.shortcutsStackView addArrangedSubview:view];
-      index++;
+    
+    CGFloat horizontalSpacing =
+    ContentSuggestionsTilesHorizontalSpacing(self.traitCollection);
+    if (self.returnToRecentTabTile) {
+        UIView* parentView = self.returnToRecentTabTile;
+        if (IsContentSuggestionsUIModuleRefreshEnabled()) {
+            self.returnToRecentTabContainer = [[ContentSuggestionsModuleContainer
+                                                alloc]
+                                               initWithContentView:self.returnToRecentTabTile
+                                               moduleType:ContentSuggestionsModuleTypeReturnToRecentTab];
+            parentView = self.returnToRecentTabContainer;
+            [self.verticalStackView
+             addArrangedSubview:self.returnToRecentTabContainer];
+        } else {
+            [self addUIElement:self.returnToRecentTabTile
+       withCustomBottomSpacing:content_suggestions::
+             kReturnToRecentTabSectionBottomMargin];
+        }
+        CGFloat cardWidth = content_suggestions::SearchFieldWidth(
+                                                                  self.view.bounds.size.width, self.traitCollection);
+        [NSLayoutConstraint activateConstraints:@[
+            [parentView.widthAnchor constraintEqualToConstant:cardWidth],
+            [parentView.heightAnchor
+             constraintEqualToConstant:ReturnToRecentTabHeight()]
+        ]];
     }
-
-    if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-      self.shortcutsModuleContainer = [[ContentSuggestionsModuleContainer alloc]
-          initWithContentView:self.shortcutsStackView
-                   moduleType:ContentSuggestionsModuleTypeShortcuts];
-      [self.verticalStackView addArrangedSubview:self.shortcutsModuleContainer];
-      CGFloat width =
-          GetModuleWidthForHorizontalTraitCollection(self.traitCollection);
-      self.shortcutsContainerWidthAnchor =
-          [self.shortcutsModuleContainer.widthAnchor
-              constraintEqualToConstant:width];
-      [NSLayoutConstraint
-          activateConstraints:@[ self.shortcutsContainerWidthAnchor ]];
-    } else {
-      [self addUIElement:self.shortcutsStackView
-          withCustomBottomSpacing:kMostVisitedBottomMargin];
-      CGFloat width =
-          MostVisitedTilesContentHorizontalSpace(self.traitCollection);
-      CGFloat height =
-          MostVisitedCellSize(self.traitCollection.preferredContentSizeCategory)
-              .height;
-      [NSLayoutConstraint activateConstraints:@[
-        [self.shortcutsStackView.widthAnchor constraintEqualToConstant:width],
-        [self.shortcutsStackView.heightAnchor
-            constraintGreaterThanOrEqualToConstant:height]
-      ]];
+    if (IsContentSuggestionsUIModuleRefreshEnabled() ||
+        [self.mostVisitedViews count] > 0) {
+        self.mostVisitedStackView = [[UIStackView alloc] init];
+        self.mostVisitedStackView.axis = UILayoutConstraintAxisVertical;
+        //self.mostVisitedStackView.distribution = UIStackViewDistributionFillEqually;
+        self.mostVisitedStackView.spacing = horizontalSpacing;
+        
+        if (IsContentSuggestionsUIModuleRefreshEnabled()) {
+            self.mostVisitedStackView.backgroundColor =
+            ntp_home::NTPBackgroundColor();
+            self.mostVisitedStackView.alignment = UIStackViewAlignmentTop;
+            self.mostVisitedModuleContainer =
+            [[ContentSuggestionsModuleContainer alloc]
+             initWithContentView:self.mostVisitedStackView
+             moduleType:ContentSuggestionsModuleTypeMostVisited];
+            if (!self.mostVisitedViews) {
+                self.mostVisitedViews = [NSMutableArray array];
+                self.mostVisitedModuleContainer.isPlaceholder = YES;
+                // Add placeholder tiles if Most Visited Tiles are not ready yet.
+                for (int i = 0; i < 4; i++) {
+                    ContentSuggestionsMostVisitedTileView* view =
+                    [[ContentSuggestionsMostVisitedTileView alloc]
+                     initWithConfiguration:nil];
+                    [self.mostVisitedViews addObject:view];
+                }
+            }
+            [self.verticalStackView
+             addArrangedSubview:self.mostVisitedModuleContainer];
+            CGFloat width =
+            GetModuleWidthForHorizontalTraitCollection(self.traitCollection);
+            self.mostVisitedContainerWidthAnchor =
+            [self.mostVisitedModuleContainer.widthAnchor
+             constraintEqualToConstant:width];
+            [NSLayoutConstraint
+             activateConstraints:@[ self.mostVisitedContainerWidthAnchor ]];
+        } else {
+            self.mostVisitedStackView.alignment = UIStackViewAlignmentTop;
+            [self addUIElement:self.mostVisitedStackView
+       withCustomBottomSpacing:kMostVisitedBottomMargin];
+            CGFloat width =
+            MostVisitedTilesContentHorizontalSpace(self.traitCollection);
+            CGFloat height =
+            MostVisitedCellSize(self.traitCollection.preferredContentSizeCategory)
+                .height;
+            [NSLayoutConstraint activateConstraints:@[
+                [self.mostVisitedStackView.widthAnchor constraintEqualToConstant:width],
+                [self.mostVisitedStackView.heightAnchor
+                 constraintGreaterThanOrEqualToConstant:height]
+            ]];
+        }
+        [self populateMostVisitedModule];
+    }
+    BOOL noTrendingQueriesToShow =
+    self.trendingQueriesReceived && [self.trendingQueryViews count] == 0;
+    if (IsTrendingQueriesModuleEnabled() && !noTrendingQueriesToShow) {
+        self.trendingQueriesContainingView = [[UIView alloc] init];
+        self.trendingQueriesModuleContainer =
+        [[ContentSuggestionsModuleContainer alloc]
+         initWithContentView:self.trendingQueriesContainingView
+         moduleType:ContentSuggestionsModuleTypeTrendingQueries];
+        if (!self.trendingQueryViews) {
+            self.trendingQueriesModuleContainer.isPlaceholder = YES;
+            self.trendingQueryViews = [NSMutableArray array];
+            // Add placeholder tiles if Most Visited Tiles are not ready yet.
+            for (int i = 0; i < 4; i++) {
+                QuerySuggestionView* view =
+                [[QuerySuggestionView alloc] initWithConfiguration:nil];
+                view.translatesAutoresizingMaskIntoConstraints = NO;
+                [self.trendingQueryViews addObject:view];
+            }
+        }
+        [self.verticalStackView
+         addArrangedSubview:self.trendingQueriesModuleContainer];
+        self.trendingQueriesContainerWidthAnchor =
+        [self.trendingQueriesModuleContainer.widthAnchor
+         constraintEqualToConstant:
+             GetModuleWidthForHorizontalTraitCollection(
+                                                        self.traitCollection)];
+        [NSLayoutConstraint
+         activateConstraints:@[ self.trendingQueriesContainerWidthAnchor ]];
+        [self populateTrendingQueriesModule];
+    }
+    if (self.shortcutsViews) {
+        self.shortcutsStackView = [[UIStackView alloc] init];
+        self.shortcutsStackView.axis = UILayoutConstraintAxisHorizontal;
+        self.shortcutsStackView.distribution = UIStackViewDistributionFillEqually;
+        self.shortcutsStackView.spacing = horizontalSpacing;
+        if (IsContentSuggestionsUIModuleRefreshEnabled()) {
+            self.shortcutsStackView.alignment = UIStackViewAlignmentTop;
+            self.shortcutsStackView.backgroundColor = ntp_home::NTPBackgroundColor();
+        } else {
+            self.shortcutsStackView.alignment = UIStackViewAlignmentTop;
+        }
+        NSUInteger index = 0;
+        for (ContentSuggestionsShortcutTileView* view in self.shortcutsViews) {
+            view.accessibilityIdentifier = [NSString
+                                            stringWithFormat:
+                                                @"%@%li",
+                                            kContentSuggestionsShortcutsAccessibilityIdentifierPrefix, index];
+            UITapGestureRecognizer* tapRecognizer = [[UITapGestureRecognizer alloc]
+                                                     initWithTarget:self
+                                                     action:@selector(contentSuggestionsElementTapped:)];
+            [view addGestureRecognizer:tapRecognizer];
+            [self.mostVisitedTapRecognizers addObject:tapRecognizer];
+            [self.shortcutsStackView addArrangedSubview:view];
+            index++;
+        }
+        
+        if (IsContentSuggestionsUIModuleRefreshEnabled()) {
+            self.shortcutsModuleContainer = [[ContentSuggestionsModuleContainer alloc]
+                                             initWithContentView:self.shortcutsStackView
+                                             moduleType:ContentSuggestionsModuleTypeShortcuts];
+            [self.verticalStackView addArrangedSubview:self.shortcutsModuleContainer];
+            CGFloat width =
+            GetModuleWidthForHorizontalTraitCollection(self.traitCollection);
+            self.shortcutsContainerWidthAnchor =
+            [self.shortcutsModuleContainer.widthAnchor
+             constraintEqualToConstant:width];
+            [NSLayoutConstraint
+             activateConstraints:@[ self.shortcutsContainerWidthAnchor ]];
+        } else {
+            [self addUIElement:self.shortcutsStackView
+       withCustomBottomSpacing:kMostVisitedBottomMargin];
+            CGFloat width =
+            MostVisitedTilesContentHorizontalSpace(self.traitCollection);
+            CGFloat height =
+            MostVisitedCellSize(self.traitCollection.preferredContentSizeCategory)
+                .height;
+            [NSLayoutConstraint activateConstraints:@[
+                [self.shortcutsStackView.widthAnchor constraintEqualToConstant:width],
+                [self.shortcutsStackView.heightAnchor
+                 constraintGreaterThanOrEqualToConstant:height]
+            ]];
+        }
     }
-  }
 }
 
 - (void)viewWillDisappear:(BOOL)animated {
-  [super viewWillDisappear:animated];
-  if (ShouldShowReturnToMostRecentTabForStartSurface()) {
-    [self.audience viewWillDisappear];
-  }
+    [super viewWillDisappear:animated];
+    if (ShouldShowReturnToMostRecentTabForStartSurface()) {
+        [self.audience viewWillDisappear];
+    }
 }
 
 #pragma mark - UIGestureRecognizerDelegate
 
 - (BOOL)gestureRecognizer:(UIGestureRecognizer*)gestureRecognizer
        shouldReceiveTouch:(UITouch*)touch {
-  return touch.view.accessibilityIdentifier !=
-             ntp_home::FakeOmniboxAccessibilityID() &&
-         touch.view.superview.accessibilityIdentifier !=
-             ntp_home::FakeOmniboxAccessibilityID();
+    return touch.view.accessibilityIdentifier !=
+    ntp_home::FakeOmniboxAccessibilityID() &&
+    touch.view.superview.accessibilityIdentifier !=
+    ntp_home::FakeOmniboxAccessibilityID();
 }
 
 #pragma mark - URLDropDelegate
 
 - (BOOL)canHandleURLDropInView:(UIView*)view {
-  return YES;
+    return YES;
 }
 
 - (void)view:(UIView*)view didDropURL:(const GURL&)URL atPoint:(CGPoint)point {
-  self.urlLoadingBrowserAgent->Load(UrlLoadParams::InCurrentTab(URL));
+    self.urlLoadingBrowserAgent->Load(UrlLoadParams::InCurrentTab(URL));
 }
 
 #pragma mark - UITraitEnvironment
 
 - (void)traitCollectionDidChange:(UITraitCollection*)previousTraitCollection {
-  [super traitCollectionDidChange:previousTraitCollection];
-  if (IsContentSuggestionsUIModuleRefreshEnabled() &&
-      previousTraitCollection.horizontalSizeClass !=
-          self.traitCollection.horizontalSizeClass) {
-    self.shortcutsContainerWidthAnchor.constant =
+    [super traitCollectionDidChange:previousTraitCollection];
+    if (IsContentSuggestionsUIModuleRefreshEnabled() &&
+        previousTraitCollection.horizontalSizeClass !=
+        self.traitCollection.horizontalSizeClass) {
+        self.shortcutsContainerWidthAnchor.constant =
         GetModuleWidthForHorizontalTraitCollection(self.traitCollection);
-    self.mostVisitedContainerWidthAnchor.constant =
+        self.mostVisitedContainerWidthAnchor.constant =
         GetModuleWidthForHorizontalTraitCollection(self.traitCollection);
-    if (IsTrendingQueriesModuleEnabled()) {
-      self.trendingQueriesContainerWidthAnchor.constant =
-          GetModuleWidthForHorizontalTraitCollection(self.traitCollection);
+        if (IsTrendingQueriesModuleEnabled()) {
+            self.trendingQueriesContainerWidthAnchor.constant =
+            GetModuleWidthForHorizontalTraitCollection(self.traitCollection);
+        }
     }
-  }
 }
 
 #pragma mark - ContentSuggestionsConsumer
 
 - (void)showReturnToRecentTabTileWithConfig:
-    (ContentSuggestionsReturnToRecentTabItem*)config {
-  if (self.returnToRecentTabTile) {
-    [self.returnToRecentTabTile removeFromSuperview];
-
-    if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-      [self.returnToRecentTabContainer removeFromSuperview];
+(ContentSuggestionsReturnToRecentTabItem*)config {
+    if (self.returnToRecentTabTile) {
+        [self.returnToRecentTabTile removeFromSuperview];
+        
+        if (IsContentSuggestionsUIModuleRefreshEnabled()) {
+            [self.returnToRecentTabContainer removeFromSuperview];
+        }
+    }
+    
+    self.returnToRecentTabTile = [[ContentSuggestionsReturnToRecentTabView alloc]
+                                  initWithConfiguration:config];
+    self.returnToRecentTabTapRecognizer = [[UITapGestureRecognizer alloc]
+                                           initWithTarget:self
+                                           action:@selector(contentSuggestionsElementTapped:)];
+    [self.returnToRecentTabTile
+     addGestureRecognizer:self.returnToRecentTabTapRecognizer];
+    self.returnToRecentTabTapRecognizer.enabled = YES;
+    // If the Content Suggestions is already shown, add the Return to Recent Tab
+    // tile to the StackView.
+    if ([[self.verticalStackView arrangedSubviews] count]) {
+        UIView* parentView = self.returnToRecentTabTile;
+        if (IsContentSuggestionsUIModuleRefreshEnabled()) {
+            self.returnToRecentTabContainer = [[ContentSuggestionsModuleContainer
+                                                alloc]
+                                               initWithContentView:self.returnToRecentTabTile
+                                               moduleType:ContentSuggestionsModuleTypeReturnToRecentTab];
+            parentView = self.returnToRecentTabContainer;
+            [self.verticalStackView
+             insertArrangedSubview:self.returnToRecentTabContainer
+             atIndex:0];
+        } else {
+            [self.verticalStackView insertArrangedSubview:self.returnToRecentTabTile
+                                                  atIndex:0];
+            [self.verticalStackView
+             setCustomSpacing:content_suggestions::
+             kReturnToRecentTabSectionBottomMargin
+             afterView:self.returnToRecentTabTile];
+        }
+        CGFloat cardWidth = content_suggestions::SearchFieldWidth(
+                                                                  self.view.bounds.size.width, self.traitCollection);
+        [NSLayoutConstraint activateConstraints:@[
+            [parentView.widthAnchor constraintEqualToConstant:cardWidth],
+            [parentView.heightAnchor
+             constraintEqualToConstant:ReturnToRecentTabHeight()]
+        ]];
+        [self.audience returnToRecentTabWasAdded];
+    }
+    // Trigger a relayout so that the Return To Recent Tab view will be counted in
+    // the Content Suggestions height. Upon app startup when this is often added
+    // asynchronously as the NTP is constructing the entire surface, so accurate
+    // height info is very important to prevent pushing content below the Return
+    // To Recent Tab view down as opposed to pushing the content above the view up
+    // if it is not counted in the height.
+    // This only has to happen after `-viewDidLoad` has completed since it is
+    // adding views after the initial layout construction in `-viewDidLoad`.
+    if (self.viewLoaded) {
+        [self.view setNeedsLayout];
+        [self.view layoutIfNeeded];
     }
-  }
-
-  self.returnToRecentTabTile = [[ContentSuggestionsReturnToRecentTabView alloc]
-      initWithConfiguration:config];
-  self.returnToRecentTabTapRecognizer = [[UITapGestureRecognizer alloc]
-      initWithTarget:self
-              action:@selector(contentSuggestionsElementTapped:)];
-  [self.returnToRecentTabTile
-      addGestureRecognizer:self.returnToRecentTabTapRecognizer];
-  self.returnToRecentTabTapRecognizer.enabled = YES;
-  // If the Content Suggestions is already shown, add the Return to Recent Tab
-  // tile to the StackView.
-  if ([[self.verticalStackView arrangedSubviews] count]) {
-    UIView* parentView = self.returnToRecentTabTile;
-    if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-      self.returnToRecentTabContainer = [[ContentSuggestionsModuleContainer
-          alloc]
-          initWithContentView:self.returnToRecentTabTile
-                   moduleType:ContentSuggestionsModuleTypeReturnToRecentTab];
-      parentView = self.returnToRecentTabContainer;
-      [self.verticalStackView
-          insertArrangedSubview:self.returnToRecentTabContainer
-                        atIndex:0];
-    } else {
-      [self.verticalStackView insertArrangedSubview:self.returnToRecentTabTile
-                                            atIndex:0];
-      [self.verticalStackView
-          setCustomSpacing:content_suggestions::
-                               kReturnToRecentTabSectionBottomMargin
-                 afterView:self.returnToRecentTabTile];
-    }
-    CGFloat cardWidth = content_suggestions::SearchFieldWidth(
-        self.view.bounds.size.width, self.traitCollection);
-    [NSLayoutConstraint activateConstraints:@[
-      [parentView.widthAnchor constraintEqualToConstant:cardWidth],
-      [parentView.heightAnchor
-          constraintEqualToConstant:ReturnToRecentTabHeight()]
-    ]];
-    [self.audience returnToRecentTabWasAdded];
-  }
-  // Trigger a relayout so that the Return To Recent Tab view will be counted in
-  // the Content Suggestions height. Upon app startup when this is often added
-  // asynchronously as the NTP is constructing the entire surface, so accurate
-  // height info is very important to prevent pushing content below the Return
-  // To Recent Tab view down as opposed to pushing the content above the view up
-  // if it is not counted in the height.
-  // This only has to happen after `-viewDidLoad` has completed since it is
-  // adding views after the initial layout construction in `-viewDidLoad`.
-  if (self.viewLoaded) {
-    [self.view setNeedsLayout];
-    [self.view layoutIfNeeded];
-  }
 }
 
 - (void)updateReturnToRecentTabTileWithConfig:
-    (ContentSuggestionsReturnToRecentTabItem*)config {
-  if (config.icon) {
-    self.returnToRecentTabTile.iconImageView.image = config.icon;
-    self.returnToRecentTabTile.iconImageView.hidden = NO;
-  }
-  if (config.title) {
-    self.returnToRecentTabTile.subtitleLabel.text = config.subtitle;
-  }
+(ContentSuggestionsReturnToRecentTabItem*)config {
+    if (config.icon) {
+        self.returnToRecentTabTile.iconImageView.image = config.icon;
+        self.returnToRecentTabTile.iconImageView.hidden = NO;
+    }
+    if (config.title) {
+        self.returnToRecentTabTile.subtitleLabel.text = config.subtitle;
+    }
 }
 
 - (void)hideReturnToRecentTabTile {
-  [self.returnToRecentTabTile removeFromSuperview];
-  self.returnToRecentTabTile = nil;
-  if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-    // Remove module container.
-    [self.returnToRecentTabContainer removeFromSuperview];
-  }
+    [self.returnToRecentTabTile removeFromSuperview];
+    self.returnToRecentTabTile = nil;
+    if (IsContentSuggestionsUIModuleRefreshEnabled()) {
+        // Remove module container.
+        [self.returnToRecentTabContainer removeFromSuperview];
+    }
 }
 
 - (void)setMostVisitedTilesWithConfigs:
-    (NSArray<ContentSuggestionsMostVisitedItem*>*)configs {
-  if (!configs) {
-    return;
-  }
-  if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-    self.mostVisitedModuleContainer.isPlaceholder = NO;
-  }
-  if ([self.mostVisitedViews count]) {
-    for (ContentSuggestionsMostVisitedTileView* view in self.mostVisitedViews) {
-      [view removeFromSuperview];
+(NSArray<ContentSuggestionsMostVisitedItem*>*)configs {
+    if (!configs) {
+        return;
     }
-    [self.mostVisitedViews removeAllObjects];
-    [self.mostVisitedTapRecognizers removeAllObjects];
-  } else {
-    self.mostVisitedViews = [NSMutableArray array];
-  }
-
-  if ([configs count] == 0) {
-    // No Most Visited Tiles to show. Remove module.
-    [self.mostVisitedStackView removeFromSuperview];
     if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-      [self.mostVisitedModuleContainer removeFromSuperview];
+        self.mostVisitedModuleContainer.isPlaceholder = NO;
     }
-    return;
-  }
-  NSInteger index = 0;
-  for (ContentSuggestionsMostVisitedItem* item in configs) {
-    ContentSuggestionsMostVisitedTileView* view =
+    if ([self.mostVisitedViews count]) {
+        for (ContentSuggestionsMostVisitedTileView* view in self.mostVisitedViews) {
+            [view removeFromSuperview];
+        }
+        [self.mostVisitedViews removeAllObjects];
+        [self.mostVisitedTapRecognizers removeAllObjects];
+        for (UIStackView* view in self.mostVisitedHorizontalStackView) {
+            [view removeFromSuperview];
+        }
+        [self.mostVisitedHorizontalStackView removeAllObjects];
+        
+        for (UIStackView* view in self.misesFeatureHorizontalStackView) {
+            [view removeFromSuperview];
+        }
+        [self.misesFeatureHorizontalStackView removeAllObjects];
+        if (self.misesEnterWeb3Cell) {
+            [self.misesEnterWeb3Cell removeFromSuperview];
+            self.misesEnterWeb3Cell = nil;
+        }
+        
+        
+    } else {
+        self.mostVisitedViews = [NSMutableArray array];
+        self.mostVisitedHorizontalStackView = [NSMutableArray array];
+        self.misesFeatureHorizontalStackView = [NSMutableArray array];
+    }
+    
+    if ([configs count] == 0) {
+        // No Most Visited Tiles to show. Remove module.
+        [self.mostVisitedStackView removeFromSuperview];
+        if (IsContentSuggestionsUIModuleRefreshEnabled()) {
+            [self.mostVisitedModuleContainer removeFromSuperview];
+        }
+        return;
+    }
+    NSInteger index = 0;
+    for (ContentSuggestionsMostVisitedItem* item in configs) {
+        ContentSuggestionsMostVisitedTileView* view =
         [[ContentSuggestionsMostVisitedTileView alloc]
-            initWithConfiguration:item];
-    view.menuProvider = self.menuProvider;
-    view.accessibilityIdentifier = [NSString
-        stringWithFormat:
-            @"%@%li",
-            kContentSuggestionsMostVisitedAccessibilityIdentifierPrefix, index];
-    [self.mostVisitedViews addObject:view];
-    index++;
-  }
-  [self populateMostVisitedModule];
-  base::RecordAction(base::UserMetricsAction("MobileNTPShowMostVisited"));
-  // Trigger a relayout so that the MVTs will be counted in the Content
-  // Suggestions height. Upon app startup when this is often added
-  // asynchronously as the NTP is constructing the entire surface, so accurate
-  // height info is very important to simulate pushing content below the MVT
-  // down as opposed to pushing the content above the MVT up if the MVTs are not
-  // counted in the height.
-  // This only has to happen after `-viewDidLoad` has completed since it is
-  // adding views after the initial layout construction in `-viewDidLoad`.
-  if (self.viewLoaded) {
-    [self.view setNeedsLayout];
-    [self.view layoutIfNeeded];
-  }
+         initWithConfiguration:item];
+        view.menuProvider = self.menuProvider;
+        view.accessibilityIdentifier = [NSString
+                                        stringWithFormat:
+                                            @"%@%li",
+                                        kContentSuggestionsMostVisitedAccessibilityIdentifierPrefix, index];
+        [self.mostVisitedViews addObject:view];
+        index++;
+    }
+    [self populateMostVisitedModule];
+    base::RecordAction(base::UserMetricsAction("MobileNTPShowMostVisited"));
+    // Trigger a relayout so that the MVTs will be counted in the Content
+    // Suggestions height. Upon app startup when this is often added
+    // asynchronously as the NTP is constructing the entire surface, so accurate
+    // height info is very important to simulate pushing content below the MVT
+    // down as opposed to pushing the content above the MVT up if the MVTs are not
+    // counted in the height.
+    // This only has to happen after `-viewDidLoad` has completed since it is
+    // adding views after the initial layout construction in `-viewDidLoad`.
+    if (self.viewLoaded) {
+        [self.view setNeedsLayout];
+        [self.view layoutIfNeeded];
+    }
 }
 
+
 - (void)setShortcutTilesWithConfigs:
-    (NSArray<ContentSuggestionsMostVisitedActionItem*>*)configs {
-  if (!self.shortcutsViews) {
-    self.shortcutsViews = [NSMutableArray array];
-  }
-  // Assumes this only called before viewDidLoad, so there is no need to add the
-  // views into the view hierarchy here.
-  for (ContentSuggestionsMostVisitedActionItem* item in configs) {
-    ContentSuggestionsShortcutTileView* view =
+(NSArray<ContentSuggestionsMostVisitedActionItem*>*)configs {
+    if (!self.shortcutsViews) {
+        self.shortcutsViews = [NSMutableArray array];
+    }
+    // Assumes this only called before viewDidLoad, so there is no need to add the
+    // views into the view hierarchy here.
+    for (ContentSuggestionsMostVisitedActionItem* item in configs) {
+        ContentSuggestionsShortcutTileView* view =
         [[ContentSuggestionsShortcutTileView alloc] initWithConfiguration:item];
-    [self.shortcutsViews addObject:view];
-  }
+        [self.shortcutsViews addObject:view];
+    }
 }
 
 - (void)updateShortcutTileConfig:
-    (ContentSuggestionsMostVisitedActionItem*)config {
-  for (ContentSuggestionsShortcutTileView* view in self.shortcutsViews) {
-    if (view.config == config) {
-      [view updateConfiguration:config];
-      return;
+(ContentSuggestionsMostVisitedActionItem*)config {
+    for (ContentSuggestionsShortcutTileView* view in self.shortcutsViews) {
+        if (view.config == config) {
+            [view updateConfiguration:config];
+            return;
+        }
     }
-  }
 }
 
 - (void)setTrendingQueriesWithConfigs:
-    (NSArray<QuerySuggestionConfig*>*)configs {
-  DCHECK(IsTrendingQueriesModuleEnabled());
-  self.trendingQueriesReceived = YES;
-  if (!self.trendingQueriesContainingView) {
-    self.trendingQueriesContainingView = [[UIView alloc] init];
-  }
-  self.trendingQueriesModuleContainer.isPlaceholder = NO;
-
-  if ([self.trendingQueryViews count]) {
-    for (QuerySuggestionView* view in self.trendingQueryViews) {
-      [view removeFromSuperview];
+(NSArray<QuerySuggestionConfig*>*)configs {
+    DCHECK(IsTrendingQueriesModuleEnabled());
+    self.trendingQueriesReceived = YES;
+    if (!self.trendingQueriesContainingView) {
+        self.trendingQueriesContainingView = [[UIView alloc] init];
     }
-    [self.trendingQueryViews removeAllObjects];
-    [self.trendingQueryTapRecognizers removeAllObjects];
-  } else {
-    self.trendingQueryViews = [NSMutableArray array];
-  }
-
-  if ((int)[configs count] < kMaxTrendingQueries) {
-    // No Trending Queries to show. Remove module.
-    [self.trendingQueriesContainingView removeFromSuperview];
-    [self.trendingQueriesModuleContainer removeFromSuperview];
-    [self.audience moduleWasRemoved];
-    return;
-  }
-
-  for (QuerySuggestionConfig* config in configs) {
-    QuerySuggestionView* view =
+    self.trendingQueriesModuleContainer.isPlaceholder = NO;
+    
+    if ([self.trendingQueryViews count]) {
+        for (QuerySuggestionView* view in self.trendingQueryViews) {
+            [view removeFromSuperview];
+        }
+        [self.trendingQueryViews removeAllObjects];
+        [self.trendingQueryTapRecognizers removeAllObjects];
+    } else {
+        self.trendingQueryViews = [NSMutableArray array];
+    }
+    
+    if ((int)[configs count] < kMaxTrendingQueries) {
+        // No Trending Queries to show. Remove module.
+        [self.trendingQueriesContainingView removeFromSuperview];
+        [self.trendingQueriesModuleContainer removeFromSuperview];
+        [self.audience moduleWasRemoved];
+        return;
+    }
+    
+    for (QuerySuggestionConfig* config in configs) {
+        QuerySuggestionView* view =
         [[QuerySuggestionView alloc] initWithConfiguration:config];
-    //      view.menuProvider = self.menuProvider;
-    view.accessibilityIdentifier =
+        //      view.menuProvider = self.menuProvider;
+        view.accessibilityIdentifier =
         [NSString stringWithFormat:@"%@", config.query];
-    view.translatesAutoresizingMaskIntoConstraints = NO;
-    [self.trendingQueryViews addObject:view];
-  }
-  [self populateTrendingQueriesModule];
+        view.translatesAutoresizingMaskIntoConstraints = NO;
+        [self.trendingQueryViews addObject:view];
+    }
+    [self populateTrendingQueriesModule];
 }
 
 - (void)updateMostVisitedTileConfig:(ContentSuggestionsMostVisitedItem*)config {
-  for (ContentSuggestionsMostVisitedTileView* view in self.mostVisitedViews) {
-    if (view.config == config) {
-      dispatch_async(dispatch_get_main_queue(), ^{
-        [view.faviconView configureWithAttributes:config.attributes];
-      });
-      return;
+    for (ContentSuggestionsMostVisitedTileView* view in self.mostVisitedViews) {
+        if (view.config == config) {
+            dispatch_async(dispatch_get_main_queue(), ^{
+                [view.faviconView configureWithAttributes:config.attributes];
+            });
+            return;
+        }
     }
-  }
 }
 
 - (CGFloat)contentSuggestionsHeight {
-  CGFloat height = 0;
-  if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-    height += [self.mostVisitedModuleContainer calculateIntrinsicHeight] +
-              ModuleVerticalSpacing();
-  } else if ([self.mostVisitedViews count] > 0) {
-    height += MostVisitedCellSize(
-                  UIApplication.sharedApplication.preferredContentSizeCategory)
-                  .height +
-              kMostVisitedBottomMargin;
-  }
-  if (IsContentSuggestionsUIModuleRefreshEnabled() &&
-      IsTrendingQueriesModuleEnabled() &&
-      [self.trendingQueriesModuleContainer superview]) {
-    height += [self.trendingQueriesModuleContainer calculateIntrinsicHeight];
-    // Only skip bottom spacing if minimizing spacing and Trending Queries is
-    // the last module.
-    if (!ShouldMinimizeSpacingForModuleRefresh() ||
-        !ShouldHideShortcutsForTrendingQueries()) {
-      height += ModuleVerticalSpacing();
-    }
-  }
-  if ([self.shortcutsViews count] > 0) {
+    CGFloat height = 0;
     if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-      height += [self.shortcutsModuleContainer calculateIntrinsicHeight];
-      if (!ShouldMinimizeSpacingForModuleRefresh()) {
-        height += ModuleVerticalSpacing();
-      }
-    } else {
-      height +=
-          MostVisitedCellSize(
-              UIApplication.sharedApplication.preferredContentSizeCategory)
-              .height;
+        height += [self.mostVisitedModuleContainer calculateIntrinsicHeight] +
+        ModuleVerticalSpacing();
+    } else if ([self.mostVisitedViews count] > 0) {
+        height += MostVisitedCellSize(
+                                      UIApplication.sharedApplication.preferredContentSizeCategory)
+        .height +
+        kMostVisitedBottomMargin;
     }
-  }
-  if (self.returnToRecentTabTile) {
-    height += ReturnToRecentTabHeight();
-    if (IsContentSuggestionsUIModuleRefreshEnabled()) {
-      height += ModuleVerticalSpacing();
+    if (IsContentSuggestionsUIModuleRefreshEnabled() &&
+        IsTrendingQueriesModuleEnabled() &&
+        [self.trendingQueriesModuleContainer superview]) {
+        height += [self.trendingQueriesModuleContainer calculateIntrinsicHeight];
+        // Only skip bottom spacing if minimizing spacing and Trending Queries is
+        // the last module.
+        if (!ShouldMinimizeSpacingForModuleRefresh() ||
+            !ShouldHideShortcutsForTrendingQueries()) {
+            height += ModuleVerticalSpacing();
+        }
     }
-  }
-  return height;
+    if ([self.shortcutsViews count] > 0) {
+        if (IsContentSuggestionsUIModuleRefreshEnabled()) {
+            height += [self.shortcutsModuleContainer calculateIntrinsicHeight];
+            if (!ShouldMinimizeSpacingForModuleRefresh()) {
+                height += ModuleVerticalSpacing();
+            }
+        } else {
+            height +=
+            MostVisitedCellSize(
+                                UIApplication.sharedApplication.preferredContentSizeCategory)
+            .height;
+        }
+    }
+    if (self.returnToRecentTabTile) {
+        height += ReturnToRecentTabHeight();
+        if (IsContentSuggestionsUIModuleRefreshEnabled()) {
+            height += ModuleVerticalSpacing();
+        }
+    }
+    return height;
 }
 
 #pragma mark - ContentSuggestionsSelectionActions
 
 - (void)contentSuggestionsElementTapped:(UIGestureRecognizer*)sender {
-  if ([sender.view
-          isKindOfClass:[ContentSuggestionsMostVisitedTileView class]]) {
-    ContentSuggestionsMostVisitedTileView* mostVisitedView =
+    if ([sender.view
+         isKindOfClass:[ContentSuggestionsMostVisitedTileView class]]) {
+        ContentSuggestionsMostVisitedTileView* mostVisitedView =
         static_cast<ContentSuggestionsMostVisitedTileView*>(sender.view);
-    [self.suggestionCommandHandler
-        openMostVisitedItem:mostVisitedView.config
-                    atIndex:mostVisitedView.config.index];
-  } else if ([sender.view
-                 isKindOfClass:[ContentSuggestionsShortcutTileView class]]) {
-    ContentSuggestionsShortcutTileView* shortcutView =
+        [self.suggestionCommandHandler
+         openMostVisitedItem:mostVisitedView.config
+         atIndex:mostVisitedView.config.index];
+    } else if ([sender.view
+                isKindOfClass:[ContentSuggestionsShortcutTileView class]]) {
+        ContentSuggestionsShortcutTileView* shortcutView =
         static_cast<ContentSuggestionsShortcutTileView*>(sender.view);
-    int index = static_cast<int>(shortcutView.config.index);
-    [self.suggestionCommandHandler openMostVisitedItem:shortcutView.config
-                                               atIndex:index];
-  } else if ([sender.view isKindOfClass:[ContentSuggestionsReturnToRecentTabView
-                                            class]]) {
-    ContentSuggestionsReturnToRecentTabView* returnToRecentTabView =
+        int index = static_cast<int>(shortcutView.config.index);
+        [self.suggestionCommandHandler openMostVisitedItem:shortcutView.config
+                                                   atIndex:index];
+    } else if ([sender.view isKindOfClass:[ContentSuggestionsReturnToRecentTabView
+                                           class]]) {
+        ContentSuggestionsReturnToRecentTabView* returnToRecentTabView =
         static_cast<ContentSuggestionsReturnToRecentTabView*>(sender.view);
-    __weak ContentSuggestionsReturnToRecentTabView* weakRecentTabView =
+        __weak ContentSuggestionsReturnToRecentTabView* weakRecentTabView =
         returnToRecentTabView;
-    UIGestureRecognizerState state = sender.state;
-    if (state == UIGestureRecognizerStateChanged ||
-        state == UIGestureRecognizerStateCancelled) {
-      // Do nothing if isn't a gesture start or end.
-      // If the gesture was cancelled by the system, then reset the background
-      // color since UIGestureRecognizerStateEnded will not be received.
-      if (state == UIGestureRecognizerStateCancelled) {
-        returnToRecentTabView.backgroundColor = [UIColor clearColor];
-      }
-      return;
-    }
-    BOOL touchBegan = state == UIGestureRecognizerStateBegan;
-    [UIView transitionWithView:returnToRecentTabView
-                      duration:kMaterialDuration8
-                       options:UIViewAnimationOptionCurveEaseInOut
-                    animations:^{
-                      weakRecentTabView.backgroundColor =
-                          touchBegan ? [UIColor colorNamed:kGrey100Color]
-                                     : [UIColor clearColor];
-                    }
-                    completion:nil];
-    if (state == UIGestureRecognizerStateEnded) {
-      CGPoint point = [sender locationInView:returnToRecentTabView];
-      if (point.x < 0 || point.y < 0 ||
-          point.x > kReturnToRecentTabSize.width ||
-          point.y > ReturnToRecentTabHeight()) {
-        // Reset the highlighted state and do nothing if the gesture ended
-        // outside of the tile.
-        returnToRecentTabView.backgroundColor = [UIColor clearColor];
-        return;
-      }
-      [self.suggestionCommandHandler openMostRecentTab];
-    }
-  } else if ([sender.view isKindOfClass:[QuerySuggestionView class]]) {
-    QuerySuggestionView* querySuggestionView =
+        UIGestureRecognizerState state = sender.state;
+        if (state == UIGestureRecognizerStateChanged ||
+            state == UIGestureRecognizerStateCancelled) {
+            // Do nothing if isn't a gesture start or end.
+            // If the gesture was cancelled by the system, then reset the background
+            // color since UIGestureRecognizerStateEnded will not be received.
+            if (state == UIGestureRecognizerStateCancelled) {
+                returnToRecentTabView.backgroundColor = [UIColor clearColor];
+            }
+            return;
+        }
+        BOOL touchBegan = state == UIGestureRecognizerStateBegan;
+        [UIView transitionWithView:returnToRecentTabView
+                          duration:kMaterialDuration8
+                           options:UIViewAnimationOptionCurveEaseInOut
+                        animations:^{
+            weakRecentTabView.backgroundColor =
+            touchBegan ? [UIColor colorNamed:kGrey100Color]
+            : [UIColor clearColor];
+        }
+                        completion:nil];
+        if (state == UIGestureRecognizerStateEnded) {
+            CGPoint point = [sender locationInView:returnToRecentTabView];
+            if (point.x < 0 || point.y < 0 ||
+                point.x > kReturnToRecentTabSize.width ||
+                point.y > ReturnToRecentTabHeight()) {
+                // Reset the highlighted state and do nothing if the gesture ended
+                // outside of the tile.
+                returnToRecentTabView.backgroundColor = [UIColor clearColor];
+                return;
+            }
+            [self.suggestionCommandHandler openMostRecentTab];
+        }
+    } else if ([sender.view isKindOfClass:[QuerySuggestionView class]]) {
+        QuerySuggestionView* querySuggestionView =
         static_cast<QuerySuggestionView*>(sender.view);
-    [self.suggestionCommandHandler
-        loadSuggestedQuery:querySuggestionView.config];
-  }
+        [self.suggestionCommandHandler
+         loadSuggestedQuery:querySuggestionView.config];
+    }
 }
 
 #pragma mark - Private
 
 - (void)addUIElement:(UIView*)view withCustomBottomSpacing:(CGFloat)spacing {
-  [self.verticalStackView addArrangedSubview:view];
-  if (spacing > 0) {
-    [self.verticalStackView setCustomSpacing:spacing afterView:view];
-  }
+    [self.verticalStackView addArrangedSubview:view];
+    if (spacing > 0) {
+        [self.verticalStackView setCustomSpacing:spacing afterView:view];
+    }
 }
 
 // Add the elements in `mostVisitedViews` into `verticalStackView`, constructing
 // `verticalStackView` beforehand if it has not been yet.
 - (void)populateMostVisitedModule {
-  // If viewDidLoad has been called before the first valid Most Visited Tiles
-  // are available, construct `mostVisitedStackView`.
-  if (!IsContentSuggestionsUIModuleRefreshEnabled() && self.verticalStackView &&
-      !self.mostVisitedStackView) {
-    self.mostVisitedStackView = [[UIStackView alloc] init];
-    self.mostVisitedStackView.axis = UILayoutConstraintAxisHorizontal;
-    self.mostVisitedStackView.alignment = UIStackViewAlignmentTop;
-    self.mostVisitedStackView.distribution = UIStackViewDistributionFillEqually;
-    self.mostVisitedStackView.spacing =
+    // If viewDidLoad has been called before the first valid Most Visited Tiles
+    // are available, construct `mostVisitedStackView`.
+    if (!IsContentSuggestionsUIModuleRefreshEnabled() && self.verticalStackView &&
+        !self.mostVisitedStackView) {
+        self.mostVisitedStackView = [[UIStackView alloc] init];
+        self.mostVisitedStackView.axis = UILayoutConstraintAxisVertical;
+        self.mostVisitedStackView.alignment = UIStackViewAlignmentTop;
+        //self.mostVisitedStackView.distribution = UIStackViewDistributionFillEqually;
+        self.mostVisitedStackView.spacing =
         ContentSuggestionsTilesHorizontalSpacing(self.traitCollection);
-    // Find correct insertion position in the stack.
-    int insertionIndex = 0;
-    if (self.returnToRecentTabTile) {
-      insertionIndex++;
+        // Find correct insertion position in the stack.
+        int insertionIndex = 0;
+        if (self.returnToRecentTabTile) {
+            insertionIndex++;
+        }
+        [self.verticalStackView insertArrangedSubview:self.mostVisitedStackView
+                                              atIndex:insertionIndex];
+        [self.verticalStackView setCustomSpacing:kMostVisitedBottomMargin
+                                       afterView:self.mostVisitedStackView];
+        CGFloat width =
+        MostVisitedTilesContentHorizontalSpace(self.traitCollection);
+        CGSize size =
+        MostVisitedCellSize(self.traitCollection.preferredContentSizeCategory);
+        [NSLayoutConstraint activateConstraints:@[
+            [self.mostVisitedStackView.widthAnchor constraintEqualToConstant:width],
+            [self.mostVisitedStackView.heightAnchor
+             constraintGreaterThanOrEqualToConstant:size.height]
+        ]];
     }
-    [self.verticalStackView insertArrangedSubview:self.mostVisitedStackView
-                                          atIndex:insertionIndex];
-    [self.verticalStackView setCustomSpacing:kMostVisitedBottomMargin
-                                   afterView:self.mostVisitedStackView];
+    for (ContentSuggestionsMostVisitedTileView* view in self.mostVisitedViews) {
+        view.menuProvider = self.menuProvider;
+        UITapGestureRecognizer* tapRecognizer = [[UITapGestureRecognizer alloc]
+                                                 initWithTarget:self
+                                                 action:@selector(contentSuggestionsElementTapped:)];
+        [view addGestureRecognizer:tapRecognizer];
+        tapRecognizer.enabled = YES;
+        [self.mostVisitedTapRecognizers addObject:tapRecognizer];
+        
+    }
+    [self buildHorizontalMostVisitedStackViews];
+}
+
+- (NSMutableArray *)buildHorizontalStackViews:(NSArray *)tileViews {
+    NSMutableArray *horizontalStackView = [NSMutableArray array];
+    UIStackView* current = NULL;
+    CGFloat horizontalSpacing =
+    ContentSuggestionsTilesHorizontalSpacing(self.traitCollection);
     CGFloat width =
-        MostVisitedTilesContentHorizontalSpace(self.traitCollection);
+    MostVisitedTilesContentHorizontalSpace(self.traitCollection);
     CGSize size =
-        MostVisitedCellSize(self.traitCollection.preferredContentSizeCategory);
+    MostVisitedCellSize(self.traitCollection.preferredContentSizeCategory);
+    for (ContentSuggestionsMostVisitedTileView* view in tileViews) {
+        if (!current) {
+            current = [[UIStackView alloc] init];
+            current.axis = UILayoutConstraintAxisHorizontal;
+            current.distribution = UIStackViewDistributionFillEqually;
+            current.spacing = horizontalSpacing;
+            current.alignment = UIStackViewAlignmentTop;
+            [NSLayoutConstraint activateConstraints:@[
+                [current.widthAnchor constraintEqualToConstant:width],
+                [current.heightAnchor
+                 constraintEqualToConstant:size.height]
+            ]];
+        }
+        [current addArrangedSubview:view];
+        if ([[current arrangedSubviews] count] == 4) {
+            [horizontalStackView addObject:current];
+            current = NULL;
+        }
+    }
+    if (current) {
+        [horizontalStackView addObject:current];
+    }
+    
+    return horizontalStackView;
+    
+}
+- (void)buildHorizontalMostVisitedStackViews  {
+    NSMutableArray *web3Tiles = [NSMutableArray array];
+    NSMutableArray *misesFeatureTiles = [NSMutableArray array];
+    for (ContentSuggestionsMostVisitedTileView* view in self.mostVisitedViews) {
+        if (view.config.isMisesFeature) {
+            [misesFeatureTiles addObject:view];
+        } else {
+            [web3Tiles addObject:view];
+        }
+    }
+    
+    self.mostVisitedHorizontalStackView = [self buildHorizontalStackViews:web3Tiles];
+    self.misesFeatureHorizontalStackView = [self buildHorizontalStackViews:misesFeatureTiles];
+    
+    CGFloat width = MostVisitedTilesContentHorizontalSpace(self.traitCollection);
+    
+    for (UIStackView* view in self.misesFeatureHorizontalStackView) {
+        [self.mostVisitedStackView addArrangedSubview:view];
+    }
+    
+    ContentSuggestionsMisesCell *cell = [[ContentSuggestionsMisesCell alloc] init];
     [NSLayoutConstraint activateConstraints:@[
-      [self.mostVisitedStackView.widthAnchor constraintEqualToConstant:width],
-      [self.mostVisitedStackView.heightAnchor
-          constraintEqualToConstant:size.height]
+        [cell.widthAnchor constraintEqualToConstant:width],
+        [cell.heightAnchor
+         constraintEqualToConstant:[ContentSuggestionsMisesCell heightForWidth:width]]
     ]];
-  }
-  for (ContentSuggestionsMostVisitedTileView* view in self.mostVisitedViews) {
-    view.menuProvider = self.menuProvider;
-    UITapGestureRecognizer* tapRecognizer = [[UITapGestureRecognizer alloc]
-        initWithTarget:self
-                action:@selector(contentSuggestionsElementTapped:)];
-    [view addGestureRecognizer:tapRecognizer];
-    tapRecognizer.enabled = YES;
-    [self.mostVisitedTapRecognizers addObject:tapRecognizer];
-    [self.mostVisitedStackView addArrangedSubview:view];
-  }
+   [cell.enterButton addTarget:self
+                               action:@selector(enterWeb3Tapped)
+                     forControlEvents:UIControlEventTouchUpInside];
+    [self.mostVisitedStackView addArrangedSubview:cell];
+    self.misesEnterWeb3Cell = cell;
+    
+    
+    for (UIStackView* view in self.mostVisitedHorizontalStackView) {
+        [self.mostVisitedStackView addArrangedSubview:view];
+    }
+    return;
 }
 
+- (void)enterWeb3Tapped {
+   [self.suggestionCommandHandler openMisesWeb3Home];
+}
 - (void)populateTrendingQueriesModule {
   for (QuerySuggestionView* view in self.trendingQueryViews) {
     UITapGestureRecognizer* tapRecognizer = [[UITapGestureRecognizer alloc]
